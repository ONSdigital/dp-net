// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package http

import (
	"context"
	"io"
	"net/http"
	"net/url"
	"sync"
	"time"
)

// Ensure, that ClienterMock does implement Clienter.
// If this is not the case, regenerate this file with moq.
var _ Clienter = &ClienterMock{}

// ClienterMock is a mock implementation of Clienter.
//
//	func TestSomethingThatUsesClienter(t *testing.T) {
//
//		// make and configure a mocked Clienter
//		mockedClienter := &ClienterMock{
//			DoFunc: func(ctx context.Context, req *http.Request) (*http.Response, error) {
//				panic("mock out the Do method")
//			},
//			GetFunc: func(ctx context.Context, url string) (*http.Response, error) {
//				panic("mock out the Get method")
//			},
//			GetMaxRetriesFunc: func() int {
//				panic("mock out the GetMaxRetries method")
//			},
//			GetPathsWithNoRetriesFunc: func() []string {
//				panic("mock out the GetPathsWithNoRetries method")
//			},
//			HeadFunc: func(ctx context.Context, url string) (*http.Response, error) {
//				panic("mock out the Head method")
//			},
//			PostFunc: func(ctx context.Context, url string, contentType string, body io.Reader) (*http.Response, error) {
//				panic("mock out the Post method")
//			},
//			PostFormFunc: func(ctx context.Context, uri string, data url.Values) (*http.Response, error) {
//				panic("mock out the PostForm method")
//			},
//			PutFunc: func(ctx context.Context, urlMoqParam string, contentType string, body io.Reader) (*http.Response, error) {
//				panic("mock out the Put method")
//			},
//			RoundTripFunc: func(req *http.Request) (*http.Response, error) {
//				panic("mock out the RoundTrip method")
//			},
//			SetMaxRetriesFunc: func(n int)  {
//				panic("mock out the SetMaxRetries method")
//			},
//			SetPathsWithNoRetriesFunc: func(strings []string)  {
//				panic("mock out the SetPathsWithNoRetries method")
//			},
//			SetTimeoutFunc: func(timeout time.Duration)  {
//				panic("mock out the SetTimeout method")
//			},
//			SetTotalTimeoutFunc: func(timeout time.Duration)  {
//				panic("mock out the SetTotalTimeout method")
//			},
//		}
//
//		// use mockedClienter in code that requires Clienter
//		// and then make assertions.
//
//	}
type ClienterMock struct {
	// DoFunc mocks the Do method.
	DoFunc func(ctx context.Context, req *http.Request) (*http.Response, error)

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, url string) (*http.Response, error)

	// GetMaxRetriesFunc mocks the GetMaxRetries method.
	GetMaxRetriesFunc func() int

	// GetPathsWithNoRetriesFunc mocks the GetPathsWithNoRetries method.
	GetPathsWithNoRetriesFunc func() []string

	// HeadFunc mocks the Head method.
	HeadFunc func(ctx context.Context, url string) (*http.Response, error)

	// PostFunc mocks the Post method.
	PostFunc func(ctx context.Context, url string, contentType string, body io.Reader) (*http.Response, error)

	// PostFormFunc mocks the PostForm method.
	PostFormFunc func(ctx context.Context, uri string, data url.Values) (*http.Response, error)

	// PutFunc mocks the Put method.
	PutFunc func(ctx context.Context, urlMoqParam string, contentType string, body io.Reader) (*http.Response, error)

	// RoundTripFunc mocks the RoundTrip method.
	RoundTripFunc func(req *http.Request) (*http.Response, error)

	// SetMaxRetriesFunc mocks the SetMaxRetries method.
	SetMaxRetriesFunc func(n int)

	// SetPathsWithNoRetriesFunc mocks the SetPathsWithNoRetries method.
	SetPathsWithNoRetriesFunc func(strings []string)

	// SetTimeoutFunc mocks the SetTimeout method.
	SetTimeoutFunc func(timeout time.Duration)

	// SetTotalTimeoutFunc mocks the SetTotalTimeout method.
	SetTotalTimeoutFunc func(timeout time.Duration)

	// calls tracks calls to the methods.
	calls struct {
		// Do holds details about calls to the Do method.
		Do []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *http.Request
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// URL is the url argument value.
			URL string
		}
		// GetMaxRetries holds details about calls to the GetMaxRetries method.
		GetMaxRetries []struct {
		}
		// GetPathsWithNoRetries holds details about calls to the GetPathsWithNoRetries method.
		GetPathsWithNoRetries []struct {
		}
		// Head holds details about calls to the Head method.
		Head []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// URL is the url argument value.
			URL string
		}
		// Post holds details about calls to the Post method.
		Post []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// URL is the url argument value.
			URL string
			// ContentType is the contentType argument value.
			ContentType string
			// Body is the body argument value.
			Body io.Reader
		}
		// PostForm holds details about calls to the PostForm method.
		PostForm []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// URI is the uri argument value.
			URI string
			// Data is the data argument value.
			Data url.Values
		}
		// Put holds details about calls to the Put method.
		Put []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UrlMoqParam is the urlMoqParam argument value.
			UrlMoqParam string
			// ContentType is the contentType argument value.
			ContentType string
			// Body is the body argument value.
			Body io.Reader
		}
		// RoundTrip holds details about calls to the RoundTrip method.
		RoundTrip []struct {
			// Req is the req argument value.
			Req *http.Request
		}
		// SetMaxRetries holds details about calls to the SetMaxRetries method.
		SetMaxRetries []struct {
			// N is the n argument value.
			N int
		}
		// SetPathsWithNoRetries holds details about calls to the SetPathsWithNoRetries method.
		SetPathsWithNoRetries []struct {
			// Strings is the strings argument value.
			Strings []string
		}
		// SetTimeout holds details about calls to the SetTimeout method.
		SetTimeout []struct {
			// Timeout is the timeout argument value.
			Timeout time.Duration
		}
		// SetTotalTimeout holds details about calls to the SetTotalTimeout method.
		SetTotalTimeout []struct {
			// Timeout is the timeout argument value.
			Timeout time.Duration
		}
	}
	lockDo                    sync.RWMutex
	lockGet                   sync.RWMutex
	lockGetMaxRetries         sync.RWMutex
	lockGetPathsWithNoRetries sync.RWMutex
	lockHead                  sync.RWMutex
	lockPost                  sync.RWMutex
	lockPostForm              sync.RWMutex
	lockPut                   sync.RWMutex
	lockRoundTrip             sync.RWMutex
	lockSetMaxRetries         sync.RWMutex
	lockSetPathsWithNoRetries sync.RWMutex
	lockSetTimeout            sync.RWMutex
	lockSetTotalTimeout       sync.RWMutex
}

// Do calls DoFunc.
func (mock *ClienterMock) Do(ctx context.Context, req *http.Request) (*http.Response, error) {
	if mock.DoFunc == nil {
		panic("ClienterMock.DoFunc: method is nil but Clienter.Do was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *http.Request
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockDo.Lock()
	mock.calls.Do = append(mock.calls.Do, callInfo)
	mock.lockDo.Unlock()
	return mock.DoFunc(ctx, req)
}

// DoCalls gets all the calls that were made to Do.
// Check the length with:
//
//	len(mockedClienter.DoCalls())
func (mock *ClienterMock) DoCalls() []struct {
	Ctx context.Context
	Req *http.Request
} {
	var calls []struct {
		Ctx context.Context
		Req *http.Request
	}
	mock.lockDo.RLock()
	calls = mock.calls.Do
	mock.lockDo.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *ClienterMock) Get(ctx context.Context, url string) (*http.Response, error) {
	if mock.GetFunc == nil {
		panic("ClienterMock.GetFunc: method is nil but Clienter.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		URL string
	}{
		Ctx: ctx,
		URL: url,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, url)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedClienter.GetCalls())
func (mock *ClienterMock) GetCalls() []struct {
	Ctx context.Context
	URL string
} {
	var calls []struct {
		Ctx context.Context
		URL string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetMaxRetries calls GetMaxRetriesFunc.
func (mock *ClienterMock) GetMaxRetries() int {
	if mock.GetMaxRetriesFunc == nil {
		panic("ClienterMock.GetMaxRetriesFunc: method is nil but Clienter.GetMaxRetries was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetMaxRetries.Lock()
	mock.calls.GetMaxRetries = append(mock.calls.GetMaxRetries, callInfo)
	mock.lockGetMaxRetries.Unlock()
	return mock.GetMaxRetriesFunc()
}

// GetMaxRetriesCalls gets all the calls that were made to GetMaxRetries.
// Check the length with:
//
//	len(mockedClienter.GetMaxRetriesCalls())
func (mock *ClienterMock) GetMaxRetriesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetMaxRetries.RLock()
	calls = mock.calls.GetMaxRetries
	mock.lockGetMaxRetries.RUnlock()
	return calls
}

// GetPathsWithNoRetries calls GetPathsWithNoRetriesFunc.
func (mock *ClienterMock) GetPathsWithNoRetries() []string {
	if mock.GetPathsWithNoRetriesFunc == nil {
		panic("ClienterMock.GetPathsWithNoRetriesFunc: method is nil but Clienter.GetPathsWithNoRetries was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetPathsWithNoRetries.Lock()
	mock.calls.GetPathsWithNoRetries = append(mock.calls.GetPathsWithNoRetries, callInfo)
	mock.lockGetPathsWithNoRetries.Unlock()
	return mock.GetPathsWithNoRetriesFunc()
}

// GetPathsWithNoRetriesCalls gets all the calls that were made to GetPathsWithNoRetries.
// Check the length with:
//
//	len(mockedClienter.GetPathsWithNoRetriesCalls())
func (mock *ClienterMock) GetPathsWithNoRetriesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetPathsWithNoRetries.RLock()
	calls = mock.calls.GetPathsWithNoRetries
	mock.lockGetPathsWithNoRetries.RUnlock()
	return calls
}

// Head calls HeadFunc.
func (mock *ClienterMock) Head(ctx context.Context, url string) (*http.Response, error) {
	if mock.HeadFunc == nil {
		panic("ClienterMock.HeadFunc: method is nil but Clienter.Head was just called")
	}
	callInfo := struct {
		Ctx context.Context
		URL string
	}{
		Ctx: ctx,
		URL: url,
	}
	mock.lockHead.Lock()
	mock.calls.Head = append(mock.calls.Head, callInfo)
	mock.lockHead.Unlock()
	return mock.HeadFunc(ctx, url)
}

// HeadCalls gets all the calls that were made to Head.
// Check the length with:
//
//	len(mockedClienter.HeadCalls())
func (mock *ClienterMock) HeadCalls() []struct {
	Ctx context.Context
	URL string
} {
	var calls []struct {
		Ctx context.Context
		URL string
	}
	mock.lockHead.RLock()
	calls = mock.calls.Head
	mock.lockHead.RUnlock()
	return calls
}

// Post calls PostFunc.
func (mock *ClienterMock) Post(ctx context.Context, url string, contentType string, body io.Reader) (*http.Response, error) {
	if mock.PostFunc == nil {
		panic("ClienterMock.PostFunc: method is nil but Clienter.Post was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		URL         string
		ContentType string
		Body        io.Reader
	}{
		Ctx:         ctx,
		URL:         url,
		ContentType: contentType,
		Body:        body,
	}
	mock.lockPost.Lock()
	mock.calls.Post = append(mock.calls.Post, callInfo)
	mock.lockPost.Unlock()
	return mock.PostFunc(ctx, url, contentType, body)
}

// PostCalls gets all the calls that were made to Post.
// Check the length with:
//
//	len(mockedClienter.PostCalls())
func (mock *ClienterMock) PostCalls() []struct {
	Ctx         context.Context
	URL         string
	ContentType string
	Body        io.Reader
} {
	var calls []struct {
		Ctx         context.Context
		URL         string
		ContentType string
		Body        io.Reader
	}
	mock.lockPost.RLock()
	calls = mock.calls.Post
	mock.lockPost.RUnlock()
	return calls
}

// PostForm calls PostFormFunc.
func (mock *ClienterMock) PostForm(ctx context.Context, uri string, data url.Values) (*http.Response, error) {
	if mock.PostFormFunc == nil {
		panic("ClienterMock.PostFormFunc: method is nil but Clienter.PostForm was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		URI  string
		Data url.Values
	}{
		Ctx:  ctx,
		URI:  uri,
		Data: data,
	}
	mock.lockPostForm.Lock()
	mock.calls.PostForm = append(mock.calls.PostForm, callInfo)
	mock.lockPostForm.Unlock()
	return mock.PostFormFunc(ctx, uri, data)
}

// PostFormCalls gets all the calls that were made to PostForm.
// Check the length with:
//
//	len(mockedClienter.PostFormCalls())
func (mock *ClienterMock) PostFormCalls() []struct {
	Ctx  context.Context
	URI  string
	Data url.Values
} {
	var calls []struct {
		Ctx  context.Context
		URI  string
		Data url.Values
	}
	mock.lockPostForm.RLock()
	calls = mock.calls.PostForm
	mock.lockPostForm.RUnlock()
	return calls
}

// Put calls PutFunc.
func (mock *ClienterMock) Put(ctx context.Context, urlMoqParam string, contentType string, body io.Reader) (*http.Response, error) {
	if mock.PutFunc == nil {
		panic("ClienterMock.PutFunc: method is nil but Clienter.Put was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		UrlMoqParam string
		ContentType string
		Body        io.Reader
	}{
		Ctx:         ctx,
		UrlMoqParam: urlMoqParam,
		ContentType: contentType,
		Body:        body,
	}
	mock.lockPut.Lock()
	mock.calls.Put = append(mock.calls.Put, callInfo)
	mock.lockPut.Unlock()
	return mock.PutFunc(ctx, urlMoqParam, contentType, body)
}

// PutCalls gets all the calls that were made to Put.
// Check the length with:
//
//	len(mockedClienter.PutCalls())
func (mock *ClienterMock) PutCalls() []struct {
	Ctx         context.Context
	UrlMoqParam string
	ContentType string
	Body        io.Reader
} {
	var calls []struct {
		Ctx         context.Context
		UrlMoqParam string
		ContentType string
		Body        io.Reader
	}
	mock.lockPut.RLock()
	calls = mock.calls.Put
	mock.lockPut.RUnlock()
	return calls
}

// RoundTrip calls RoundTripFunc.
func (mock *ClienterMock) RoundTrip(req *http.Request) (*http.Response, error) {
	if mock.RoundTripFunc == nil {
		panic("ClienterMock.RoundTripFunc: method is nil but Clienter.RoundTrip was just called")
	}
	callInfo := struct {
		Req *http.Request
	}{
		Req: req,
	}
	mock.lockRoundTrip.Lock()
	mock.calls.RoundTrip = append(mock.calls.RoundTrip, callInfo)
	mock.lockRoundTrip.Unlock()
	return mock.RoundTripFunc(req)
}

// RoundTripCalls gets all the calls that were made to RoundTrip.
// Check the length with:
//
//	len(mockedClienter.RoundTripCalls())
func (mock *ClienterMock) RoundTripCalls() []struct {
	Req *http.Request
} {
	var calls []struct {
		Req *http.Request
	}
	mock.lockRoundTrip.RLock()
	calls = mock.calls.RoundTrip
	mock.lockRoundTrip.RUnlock()
	return calls
}

// SetMaxRetries calls SetMaxRetriesFunc.
func (mock *ClienterMock) SetMaxRetries(n int) {
	if mock.SetMaxRetriesFunc == nil {
		panic("ClienterMock.SetMaxRetriesFunc: method is nil but Clienter.SetMaxRetries was just called")
	}
	callInfo := struct {
		N int
	}{
		N: n,
	}
	mock.lockSetMaxRetries.Lock()
	mock.calls.SetMaxRetries = append(mock.calls.SetMaxRetries, callInfo)
	mock.lockSetMaxRetries.Unlock()
	mock.SetMaxRetriesFunc(n)
}

// SetMaxRetriesCalls gets all the calls that were made to SetMaxRetries.
// Check the length with:
//
//	len(mockedClienter.SetMaxRetriesCalls())
func (mock *ClienterMock) SetMaxRetriesCalls() []struct {
	N int
} {
	var calls []struct {
		N int
	}
	mock.lockSetMaxRetries.RLock()
	calls = mock.calls.SetMaxRetries
	mock.lockSetMaxRetries.RUnlock()
	return calls
}

// SetPathsWithNoRetries calls SetPathsWithNoRetriesFunc.
func (mock *ClienterMock) SetPathsWithNoRetries(strings []string) {
	if mock.SetPathsWithNoRetriesFunc == nil {
		panic("ClienterMock.SetPathsWithNoRetriesFunc: method is nil but Clienter.SetPathsWithNoRetries was just called")
	}
	callInfo := struct {
		Strings []string
	}{
		Strings: strings,
	}
	mock.lockSetPathsWithNoRetries.Lock()
	mock.calls.SetPathsWithNoRetries = append(mock.calls.SetPathsWithNoRetries, callInfo)
	mock.lockSetPathsWithNoRetries.Unlock()
	mock.SetPathsWithNoRetriesFunc(strings)
}

// SetPathsWithNoRetriesCalls gets all the calls that were made to SetPathsWithNoRetries.
// Check the length with:
//
//	len(mockedClienter.SetPathsWithNoRetriesCalls())
func (mock *ClienterMock) SetPathsWithNoRetriesCalls() []struct {
	Strings []string
} {
	var calls []struct {
		Strings []string
	}
	mock.lockSetPathsWithNoRetries.RLock()
	calls = mock.calls.SetPathsWithNoRetries
	mock.lockSetPathsWithNoRetries.RUnlock()
	return calls
}

// SetTimeout calls SetTimeoutFunc.
func (mock *ClienterMock) SetTimeout(timeout time.Duration) {
	if mock.SetTimeoutFunc == nil {
		panic("ClienterMock.SetTimeoutFunc: method is nil but Clienter.SetTimeout was just called")
	}
	callInfo := struct {
		Timeout time.Duration
	}{
		Timeout: timeout,
	}
	mock.lockSetTimeout.Lock()
	mock.calls.SetTimeout = append(mock.calls.SetTimeout, callInfo)
	mock.lockSetTimeout.Unlock()
	mock.SetTimeoutFunc(timeout)
}

// SetTimeoutCalls gets all the calls that were made to SetTimeout.
// Check the length with:
//
//	len(mockedClienter.SetTimeoutCalls())
func (mock *ClienterMock) SetTimeoutCalls() []struct {
	Timeout time.Duration
} {
	var calls []struct {
		Timeout time.Duration
	}
	mock.lockSetTimeout.RLock()
	calls = mock.calls.SetTimeout
	mock.lockSetTimeout.RUnlock()
	return calls
}

// SetTotalTimeout calls SetTotalTimeoutFunc.
func (mock *ClienterMock) SetTotalTimeout(timeout time.Duration) {
	if mock.SetTotalTimeoutFunc == nil {
		panic("ClienterMock.SetTotalTimeoutFunc: method is nil but Clienter.SetTotalTimeout was just called")
	}
	callInfo := struct {
		Timeout time.Duration
	}{
		Timeout: timeout,
	}
	mock.lockSetTotalTimeout.Lock()
	mock.calls.SetTotalTimeout = append(mock.calls.SetTotalTimeout, callInfo)
	mock.lockSetTotalTimeout.Unlock()
	mock.SetTotalTimeoutFunc(timeout)
}

// SetTotalTimeoutCalls gets all the calls that were made to SetTotalTimeout.
// Check the length with:
//
//	len(mockedClienter.SetTotalTimeoutCalls())
func (mock *ClienterMock) SetTotalTimeoutCalls() []struct {
	Timeout time.Duration
} {
	var calls []struct {
		Timeout time.Duration
	}
	mock.lockSetTotalTimeout.RLock()
	calls = mock.calls.SetTotalTimeout
	mock.lockSetTotalTimeout.RUnlock()
	return calls
}
