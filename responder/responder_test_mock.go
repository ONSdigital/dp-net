// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package responder

import (
	"context"
	"net/http"
	"sync"
)

// Ensure, that RequestResponderMock does implement RequestResponder.
// If this is not the case, regenerate this file with moq.
var _ RequestResponder = &RequestResponderMock{}

// RequestResponderMock is a mock implementation of RequestResponder.
//
//	func TestSomethingThatUsesRequestResponder(t *testing.T) {
//
//		// make and configure a mocked RequestResponder
//		mockedRequestResponder := &RequestResponderMock{
//			BytesFunc: func(ctx context.Context, w http.ResponseWriter, status int, resp []byte)  {
//				panic("mock out the Bytes method")
//			},
//			ErrorFunc: func(ctx context.Context, w http.ResponseWriter, status int, err error)  {
//				panic("mock out the Error method")
//			},
//			ErrorsFunc: func(ctx context.Context, w http.ResponseWriter, status int, errs []error)  {
//				panic("mock out the Errors method")
//			},
//			JSONFunc: func(ctx context.Context, w http.ResponseWriter, status int, resp interface{})  {
//				panic("mock out the JSON method")
//			},
//			StatusCodeFunc: func(w http.ResponseWriter, status int)  {
//				panic("mock out the StatusCode method")
//			},
//		}
//
//		// use mockedRequestResponder in code that requires RequestResponder
//		// and then make assertions.
//
//	}
type RequestResponderMock struct {
	// BytesFunc mocks the Bytes method.
	BytesFunc func(ctx context.Context, w http.ResponseWriter, status int, resp []byte)

	// ErrorFunc mocks the Error method.
	ErrorFunc func(ctx context.Context, w http.ResponseWriter, status int, err error)

	// ErrorsFunc mocks the Errors method.
	ErrorsFunc func(ctx context.Context, w http.ResponseWriter, status int, errs []error)

	// JSONFunc mocks the JSON method.
	JSONFunc func(ctx context.Context, w http.ResponseWriter, status int, resp interface{})

	// StatusCodeFunc mocks the StatusCode method.
	StatusCodeFunc func(w http.ResponseWriter, status int)

	// calls tracks calls to the methods.
	calls struct {
		// Bytes holds details about calls to the Bytes method.
		Bytes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// W is the w argument value.
			W http.ResponseWriter
			// Status is the status argument value.
			Status int
			// Resp is the resp argument value.
			Resp []byte
		}
		// Error holds details about calls to the Error method.
		Error []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// W is the w argument value.
			W http.ResponseWriter
			// Status is the status argument value.
			Status int
			// Err is the err argument value.
			Err error
		}
		// Errors holds details about calls to the Errors method.
		Errors []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// W is the w argument value.
			W http.ResponseWriter
			// Status is the status argument value.
			Status int
			// Errs is the errs argument value.
			Errs []error
		}
		// JSON holds details about calls to the JSON method.
		JSON []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// W is the w argument value.
			W http.ResponseWriter
			// Status is the status argument value.
			Status int
			// Resp is the resp argument value.
			Resp interface{}
		}
		// StatusCode holds details about calls to the StatusCode method.
		StatusCode []struct {
			// W is the w argument value.
			W http.ResponseWriter
			// Status is the status argument value.
			Status int
		}
	}
	lockBytes      sync.RWMutex
	lockError      sync.RWMutex
	lockErrors     sync.RWMutex
	lockJSON       sync.RWMutex
	lockStatusCode sync.RWMutex
}

// Bytes calls BytesFunc.
func (mock *RequestResponderMock) Bytes(ctx context.Context, w http.ResponseWriter, status int, resp []byte) {
	if mock.BytesFunc == nil {
		panic("RequestResponderMock.BytesFunc: method is nil but RequestResponder.Bytes was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		W      http.ResponseWriter
		Status int
		Resp   []byte
	}{
		Ctx:    ctx,
		W:      w,
		Status: status,
		Resp:   resp,
	}
	mock.lockBytes.Lock()
	mock.calls.Bytes = append(mock.calls.Bytes, callInfo)
	mock.lockBytes.Unlock()
	mock.BytesFunc(ctx, w, status, resp)
}

// BytesCalls gets all the calls that were made to Bytes.
// Check the length with:
//
//	len(mockedRequestResponder.BytesCalls())
func (mock *RequestResponderMock) BytesCalls() []struct {
	Ctx    context.Context
	W      http.ResponseWriter
	Status int
	Resp   []byte
} {
	var calls []struct {
		Ctx    context.Context
		W      http.ResponseWriter
		Status int
		Resp   []byte
	}
	mock.lockBytes.RLock()
	calls = mock.calls.Bytes
	mock.lockBytes.RUnlock()
	return calls
}

// Error calls ErrorFunc.
func (mock *RequestResponderMock) Error(ctx context.Context, w http.ResponseWriter, status int, err error) {
	if mock.ErrorFunc == nil {
		panic("RequestResponderMock.ErrorFunc: method is nil but RequestResponder.Error was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		W      http.ResponseWriter
		Status int
		Err    error
	}{
		Ctx:    ctx,
		W:      w,
		Status: status,
		Err:    err,
	}
	mock.lockError.Lock()
	mock.calls.Error = append(mock.calls.Error, callInfo)
	mock.lockError.Unlock()
	mock.ErrorFunc(ctx, w, status, err)
}

// ErrorCalls gets all the calls that were made to Error.
// Check the length with:
//
//	len(mockedRequestResponder.ErrorCalls())
func (mock *RequestResponderMock) ErrorCalls() []struct {
	Ctx    context.Context
	W      http.ResponseWriter
	Status int
	Err    error
} {
	var calls []struct {
		Ctx    context.Context
		W      http.ResponseWriter
		Status int
		Err    error
	}
	mock.lockError.RLock()
	calls = mock.calls.Error
	mock.lockError.RUnlock()
	return calls
}

// Errors calls ErrorsFunc.
func (mock *RequestResponderMock) Errors(ctx context.Context, w http.ResponseWriter, status int, errs []error) {
	if mock.ErrorsFunc == nil {
		panic("RequestResponderMock.ErrorsFunc: method is nil but RequestResponder.Errors was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		W      http.ResponseWriter
		Status int
		Errs   []error
	}{
		Ctx:    ctx,
		W:      w,
		Status: status,
		Errs:   errs,
	}
	mock.lockErrors.Lock()
	mock.calls.Errors = append(mock.calls.Errors, callInfo)
	mock.lockErrors.Unlock()
	mock.ErrorsFunc(ctx, w, status, errs)
}

// ErrorsCalls gets all the calls that were made to Errors.
// Check the length with:
//
//	len(mockedRequestResponder.ErrorsCalls())
func (mock *RequestResponderMock) ErrorsCalls() []struct {
	Ctx    context.Context
	W      http.ResponseWriter
	Status int
	Errs   []error
} {
	var calls []struct {
		Ctx    context.Context
		W      http.ResponseWriter
		Status int
		Errs   []error
	}
	mock.lockErrors.RLock()
	calls = mock.calls.Errors
	mock.lockErrors.RUnlock()
	return calls
}

// JSON calls JSONFunc.
func (mock *RequestResponderMock) JSON(ctx context.Context, w http.ResponseWriter, status int, resp interface{}) {
	if mock.JSONFunc == nil {
		panic("RequestResponderMock.JSONFunc: method is nil but RequestResponder.JSON was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		W      http.ResponseWriter
		Status int
		Resp   interface{}
	}{
		Ctx:    ctx,
		W:      w,
		Status: status,
		Resp:   resp,
	}
	mock.lockJSON.Lock()
	mock.calls.JSON = append(mock.calls.JSON, callInfo)
	mock.lockJSON.Unlock()
	mock.JSONFunc(ctx, w, status, resp)
}

// JSONCalls gets all the calls that were made to JSON.
// Check the length with:
//
//	len(mockedRequestResponder.JSONCalls())
func (mock *RequestResponderMock) JSONCalls() []struct {
	Ctx    context.Context
	W      http.ResponseWriter
	Status int
	Resp   interface{}
} {
	var calls []struct {
		Ctx    context.Context
		W      http.ResponseWriter
		Status int
		Resp   interface{}
	}
	mock.lockJSON.RLock()
	calls = mock.calls.JSON
	mock.lockJSON.RUnlock()
	return calls
}

// StatusCode calls StatusCodeFunc.
func (mock *RequestResponderMock) StatusCode(w http.ResponseWriter, status int) {
	if mock.StatusCodeFunc == nil {
		panic("RequestResponderMock.StatusCodeFunc: method is nil but RequestResponder.StatusCode was just called")
	}
	callInfo := struct {
		W      http.ResponseWriter
		Status int
	}{
		W:      w,
		Status: status,
	}
	mock.lockStatusCode.Lock()
	mock.calls.StatusCode = append(mock.calls.StatusCode, callInfo)
	mock.lockStatusCode.Unlock()
	mock.StatusCodeFunc(w, status)
}

// StatusCodeCalls gets all the calls that were made to StatusCode.
// Check the length with:
//
//	len(mockedRequestResponder.StatusCodeCalls())
func (mock *RequestResponderMock) StatusCodeCalls() []struct {
	W      http.ResponseWriter
	Status int
} {
	var calls []struct {
		W      http.ResponseWriter
		Status int
	}
	mock.lockStatusCode.RLock()
	calls = mock.calls.StatusCode
	mock.lockStatusCode.RUnlock()
	return calls
}
